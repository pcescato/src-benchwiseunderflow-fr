---
title: mailstail ou comment unifier et prioriser vos bo√Ætes mail
pubDate: "2025-07-15T21:38:31+00:00"
updated: "2025-07-16T12:29:19+00:00"
slug: "mailstail-unifier-prioriser-boites-mail"
draft: false
categories:
  - "PoC"
tags:
  - "client mail intelligent"
  - "Docker"
  - "Exchange"
  - "Gmail"
  - "IMAP"
  - "NLP"
  - "OAuth2"
  - "open source"
  - "prototype"
  - "Python FastAPI"
  - "React Vite"
  - "spaCy"
description: "Jongler entre plusieurs bo√Ætes mail devient vite un enfer. J'ai d√©velopp√© mailstail, une interface l√©g√®re qui centralise Gmail, Yahoo, IMAP et autres, avec un scoring automatique pour prioriser l'important. Un PoC open source pour reprendre le contr√¥le de sa messagerie."
image: /image/pexels-photo-193003-193003-scaled.avif

---

import { Code } from 'astro-expressive-code/components'


J'ai r√©cemment trouv√©, quelque part sur le web, des infos concernant [gmailtail](https://github.com/c4pt0r/gmailtail) ‚Äì un petit outil malin capable d'extraire au format JSON les courriels re√ßus dans votre bo√Æte Gmail.



Mais cet outil est limit√© √† Gmail. Or moi, ce que je voulais, c'√©tait un **client mail intelligent** transversal : Gmail, Yahoo, Exchange, Free, Orange, ou tout simplement ma bo√Æte mail perso en IMAP, h√©berg√©e chez un fournisseur classique.



Alors j'ai pos√© mon id√©e.



Puis j'ai commenc√© √† prototyper un outil, que j'ai appel√© **mailstail**. Une **interface mail multi-comptes** l√©g√®re, intelligente, capable de me montrer en un coup d'≈ìil ce qui est important‚Ä¶ ou pas.



## Objectifs fonctionnels



Ce que je voulais pour cette **interface mail multi-comptes**, c'√©tait tr√®s simple (du moins en apparence) :



* voir les derniers courriels re√ßus (toutes bo√Ætes confondues)
* **prioriser les emails** automatiquement (important / moyen / faible)
* r√©pondre directement depuis l'interface
* supprimer un ind√©sirable en un clic
* √©ventuellement : proposer une r√©ponse automatique (LLM) ou un r√©sum√© intelligent



## Panorama des solutions existantes



Aujourd'hui, si vous consultez vos mails, vous avez plus ou moins deux choix :



* soit vous utilisez l'interface web du fournisseur (Gmail, Outlook, Free, etc.)
* soit vous passez par un **client mail** lourd comme Thunderbird ou Outlook



Mais d√®s que vous avez plus d'une bo√Æte mail, √ßa devient un enfer :



J'ai une adresse perso, une autre "officielle" (fournisseurs de services, imp√¥ts, CAF, avocat‚Ä¶), une adresse universitaire, une adresse pro‚Ä¶ et chaque jour, je dois passer d'un onglet √† l'autre, ou d'un compte √† l'autre.



Soit je passe d'onglet en onglet dans un navigateur web, en ayant devant les yeux une masse informe de courriels venus d'ici et d'ailleurs, soit je consulte mon application (Thunderbird), mais dans chaque dossier, j'ai la m√™me masse informe de courriels √† traiter. Et en plus, je ne pense pas forc√©ment √† consulter chaque dossier.



Autant dire que la d√©couverte de cet outil m'a interpel√©, et que j'ai eu envie de d√©velopper une **interface mail intelligente** qui me permette d'optimiser mon temps de consultation.



Je passe :



* d'une masse informe de mails dans tous les sens,
* sans aucun rep√®re visuel,
* sans aucune aide √† la d√©cision



√† :



* une information structur√©e,
* une visualisation rapide des messages importants
* avec une possibilit√© d'interagir en temps r√©el



## Les outils d'analyse automatique pour emails



En creusant, j'ai d√©couvert plusieurs briques technologiques pour le **scoring automatique** des emails :



* **Lettria** : puissante, mais un peu usine √† gaz pour un besoin simple
* **spaCy** : rapide, fiable, personnalisable (et open source)
* **CamemBERT** : efficace, mais plus lourd (Transformers, GPU, RAM‚Ä¶)
* **Mailparser.io** : int√©ressant pour des formulaires ou flux structur√©s



Mon choix : rester l√©ger avec **spaCy NLP**, en int√©grant un syst√®me de **scoring pond√©r√©** bas√© sur les mots-cl√©s et les entit√©s nomm√©es.



## Architecture globale



Un seul mot d'ordre : simplicit√© et robustesse.

<Code code={`graph TD
A["R√©cup√©ration IMAP/API"] --> B["Scoring spaCy"]
B --> C["Affichage frontend (React)"]
C --> D["R√©ponse manuelle ou auto"]
C --> E["Suppression / action"]
`} lang="mermaid" />

## Choix techniques initiaux



Le **backend** est construit en **Python**, un langage que je ma√Ætrise bien et qui offre un excellent √©cosyst√®me pour tout ce qui est traitement de texte, NLP et **gestion d'emails** (IMAP, encodage, parsing multipart‚Ä¶). C'est aussi un langage bien document√©, id√©al pour construire une base robuste et √©volutive.



Pour la couche API, j'ai opt√© pour **FastAPI**. Pourquoi FastAPI et pas Flask ? D'abord pour la vitesse de d√©veloppement, ensuite pour la d√©tection automatique des types, la documentation Swagger int√©gr√©e, et enfin parce qu'il est con√ßu pour du asynchrone ‚Äì ce qui me permettra plus tard de scaler ou de passer √† du multi-thread sans tout refaire.



C√¥t√© **frontend**, le choix s'est port√© sur **React** pour sa large communaut√© et sa souplesse. Associ√© √† **Vite** (plut√¥t que Webpack), le combo permet une compilation rapide, un rechargement ultra-fluide en d√©veloppement, et une **interface responsive** moderne mais l√©g√®re. J'avais aussi envisag√© Vue, mais React reste √† mes yeux plus robuste et plus maintenu √† long terme.



Enfin, **Docker** s'est impos√© pour encapsuler le tout. Avec **Docker Compose**, je peux builder, lancer, d√©ployer et mettre √† jour l'ensemble du projet (frontend + backend + proxy) en une seule ligne. Ce n'√©tait pas indispensable au d√©but, mais c'est vite devenu essentiel pour tester sur diff√©rents environnements.



## Architecture technique d√©taill√©e



Un seul mot d'ordre : simplicit√© et robustesse.



**R√©cup√©ration IMAP/API ‚Üí Scoring spaCy ‚Üí Affichage frontend (React) ‚Üí R√©ponse manuelle ou auto ‚Üí Suppression / action**



* **IMAP + OAuth2** pour compatibilit√© avec Gmail, Yahoo, etc.
* Fallback avec mot de passe (Free, Orange, etc.)
* Affichage **multi-comptes mail**, avec ic√¥ne color√©e selon la source
* **Priorisation automatique** par niveau d'importance
* Logs des mails analys√©s pour audit ou r√©troaction



## D√©tails techniques



L'un des enjeux d√®s le d√©part √©tait de faire tourner ce projet m√™me sur des configurations modestes (ex. : VPS √† 1 vCPU, 512 Mo de RAM). Il fallait donc √©viter les solutions trop lourdes ou trop exigeantes.



C√¥t√© backend, j'ai pr√©f√©r√© un traitement s√©quentiel simple au d√©part, plut√¥t que d'impl√©menter de l'asynchrone ou du multithread trop t√¥t. **FastAPI** permet de faire du async proprement, mais encore fallait-il ne pas compliquer inutilement la logique de traitement d√®s la premi√®re version. La structure actuelle pourrait facilement basculer vers du async ou de la file de t√¢ches plus tard, mais ce n'est pas une priorit√© √† ce stade.



Pour les **connexions IMAP**, j'ai int√©gr√© un gestionnaire de session capable de distinguer les connexions **OAuth2** (pour Gmail, Outlook, Yahoo‚Ä¶) des connexions par mot de passe applicatif plus classiques. Le principe est simple : si les variables d'environnement contiennent un **token OAuth2** valide, on utilise ce mode d'authentification, sinon, on revient √† une authentification classique. Le backend est donc capable d'ajuster dynamiquement sa m√©thode d'authentification sans que l'utilisateur n'ait √† faire le moindre choix manuel.



Le **parsing des emails** a n√©cessit√© pas mal de soin pour g√©rer toutes les variantes : encodage bizarre, contenus multipart avec pi√®ces jointes, HTML crades, etc. L√† encore, un traitement robuste mais l√©ger √©tait le bon compromis.



C√¥t√© **scoring intelligent**, spaCy est rapide, mais il a fallu calibrer la pond√©ration pour obtenir des r√©sultats pertinents sans tomber dans le sur-apprentissage ou le scoring gadget. J'ai aussi loggu√© tous les mails trait√©s dans un fichier .jsonl pour pouvoir analyser et ajuster le scoring a posteriori.



Sur le **frontend React**, React m'a permis de d√©couper proprement l'affichage des messages (aper√ßu, d√©tail, r√©ponse), et d'ajouter facilement des fonctionnalit√©s interactives (bouton ¬´ R√©pondre ¬ª, champ rich text cach√© par d√©faut, priorisation par couleur). Le choix de **Vite** a permis un cycle de d√©veloppement tr√®s fluide et des builds rapides, m√™me sur machine modeste.



### Backend FastAPI



Le **backend FastAPI** est le c≈ìur du traitement de l'application. Il est con√ßu pour recevoir des requ√™tes REST via FastAPI, traiter les mails (connexion IMAP ou via API), extraire leur contenu, appliquer un **scoring automatique** et renvoyer les donn√©es sous forme de JSON au frontend.



**FastAPI** a √©t√© choisi pour :



* sa rapidit√© de d√©veloppement,
* son support natif de l'asynchrone (utile pour g√©rer plusieurs **connexions IMAP** en parall√®le √† terme),
* sa documentation automatique (Swagger UI tr√®s utile en d√©veloppement),
* et sa tr√®s bonne int√©gration avec Pydantic pour la validation des mod√®les.



Les **routes principales** expos√©es sont :



* **GET /api/messages** : r√©cup√®re les mails tri√©s et scor√©s
* **POST /api/reply** : envoie une r√©ponse √† un mail donn√©



Le backend est √©galement responsable de :



* l'**authentification OAuth2** (avec refresh automatique),
* la **gestion multi-comptes**,
* l'**analyse des emails** avec spaCy (entit√©s + mots-cl√©s pond√©r√©s),
* le logging dans un fichier JSONL (audit, d√©bogage, entra√Ænement futur).



Il est con√ßu pour tourner dans un conteneur **Docker** isol√©, avec son mod√®le spaCy pr√©charg√© et mont√© via volume.



Fonctionnalit√©s principales :



* **Authentification dynamique** selon les credentials disponibles (mot de passe ou OAuth2)
* **Parsing robuste** des mails (multipart, charset, encodage‚Ä¶)
* **Scoring pond√©r√©** (keywords + entit√©s via spaCy)
* Exposition des mails via **API REST** /api/messages
* Support de la r√©ponse via /api/reply



#### Logging JSONL pour le scoring



Chaque mail analys√© est loggu√© sous forme d‚Äôun objet JSON compact, stock√© ligne par ligne dans un fichier `.jsonl`. Cela permet :



* de conserver un historique l√©ger et exploitable,
* de recalculer le scoring avec de nouveaux param√®tres,
* de visualiser les entit√©s d√©tect√©es et le niveau de priorit√© attribu√©,
* d'entra√Æner √©ventuellement un mod√®le de classification supervis√©e √† l‚Äôavenir.



Chaque entr√©e comprend typiquement : `timestamp`, `expediteur`, `sujet`, `score_final`, `entites`, `mots_cles_detectes`, `id_message`.



### Frontend React



Le **frontend React** repose sur React, avec **Vite** comme outil de compilation. L'objectif √©tait d'avoir une **interface l√©g√®re** √† charger, r√©active, sans fioritures.



Les choix structurants :



* utilisation de **composants React** l√©gers,
* chargement progressif des contenus (aper√ßu ‚Üí d√©tail ‚Üí r√©ponse),
* int√©gration de **Quill.js** pour le champ de r√©ponse en rich text,
* design **responsive** et compact pour pouvoir afficher l'essentiel m√™me sur petit √©cran.



Parmi les √©l√©ments notables de l'**interface mail** :



* un indicateur color√© : üî¥ üü† ‚ö™ pour la priorit√©,
* une ic√¥ne indiquant le compte d'origine (**Gmail**, **Yahoo**, etc.),
* une gestion des mails par aper√ßu, avec les 3 premi√®res lignes visibles avec un bouton ou un lien ¬´ d√©velopper / replier ¬ª,
* un bouton "R√©pondre" qui d√©clenche le chargement conditionnel de **Quill.js** (non mont√© par d√©faut, pour ne pas alourdir le DOM).



L'ensemble communique avec le backend via fetch sur les routes **/api/messages** et **/api/reply**. Les erreurs de token, de quota ou de format de mail sont g√©r√©es proprement c√¥t√© interface.



Fonctionnalit√©s principales :



* Liste des mails avec code couleur + source visuelle
* Affichage des 3 premi√®res lignes avec bouton ¬´ Voir la suite ¬ª
* Champ de r√©ponse rich text int√©gr√© (**Quill.js**)
* **Composants r√©actifs** et l√©gers (Vite)



### Docker & Nginx



Avant de choisir **Nginx**, j'ai pris le temps d'√©valuer ce qu'offraient Apache et OpenLiteSpeed. Apache, aurait pu faire l'affaire. Mais il est plus lourd, plus verbeux, et n√©cessite plus de configuration pour un simple **reverse proxy**.



Quant √† OpenLiteSpeed, [que je connais bien](/blog/cyberpanel-openlitespeed-lscache/), il est rapide et moderne, mais sa configuration en container est un peu capricieuse, surtout quand il s'agit d'un projet d√©coup√© en microservices.



Finalement, j'ai choisi **Nginx** pour sa simplicit√©, sa stabilit√©, et sa documentation ultra-compl√®te. Il s'est impos√© comme le bon choix pour :



* Servir le **frontend React** compil√©,
* Proxifier les requ√™tes vers /api/ vers **FastAPI**,
* Offrir un point d'entr√©e unique (id√©al pour la gestion des CORS et des certificats SSL).



Il est int√©gr√© au projet via **Docker Compose**, avec une configuration minimale mais robuste, et peut √™tre remplac√© ou ignor√© si l'on d√©ploie sur une stack diff√©rente (par exemple un h√©bergement manag√© avec son propre reverse proxy).



### Gestion du rafra√Æchissement des tokens OAuth2



L'un des points cruciaux avec **OAuth2**, c'est que le **token d'acc√®s** fourni par le provider (comme **Google** ou **Yahoo**) a une dur√©e de vie limit√©e ‚Äì souvent autour d'une heure. Pour √©viter de devoir redemander une autorisation √† l'utilisateur √† chaque fois, il faut donc g√©rer un **refresh token**.



Dans **mailstail**, j'ai mis en place un m√©canisme automatique dans le backend :



* Le **token d'acc√®s** est v√©rifi√© √† chaque appel.
* Si le token est expir√©, une requ√™te est faite vers le serveur **OAuth2** (via requests.post) pour obtenir un nouveau token d'acc√®s √† partir du **refresh token**.
* Les nouveaux tokens sont mis √† jour dans un petit fichier de cache s√©curis√©, de mani√®re transparente pour l'utilisateur.



Cela permet de maintenir une connexion stable et continue, sans intervention manuelle.



## D√©fis rencontr√©s & solutions apport√©es




| D√©fi | Solution |
| --- | --- |
| Rafra√Æchissement des **tokens OAuth2** | Automatis√© dans backend |
| **Parsing HTML/texte** complexe | Fallback vers contenu brut |
| Calibrage du **scoring** | Pond√©ration progressive selon entit√©s |
| Quotas **Gmail API** | Fallback **IMAP** natif s√©curis√© |
| **UI lisible** malgr√© la complexit√© | Composants **React** modulaires + progressive disclosure |




## Perspectives d'√©volution



* Moteur de r√®gles personnalisables (par l'utilisateur)
* Envoi direct depuis l'**interface mail**
* R√©sum√©s + propositions de r√©ponse via LLM (optionnel)
* Multilingue
* Portage mobile + notifications push



## Pourquoi aucune solution "cl√© en main" ne suffisait ?



Parce qu'aucune ne proposait √† la fois :



* une **interface ultra-l√©g√®re** et rapide
* le support **multi-comptes IMAP**
* un **scoring intelligent** mais lisible
* un **backend open-source** personnalisable



## Conclusion



Ce projet m'a permis de concilier plusieurs choses :



* mes besoins d'utilisateur exigeant
* mes comp√©tences techniques (**Python**, **NLP**, **React**)
* mon envie de rester ma√Ætre de mes donn√©es



Et surtout : il m'a fait **gagner du temps**.



üì¶ Le projet est libre, sous licence MIT.  
üîó [ D√©p√¥t GitHub : [https://github.com/pcescato/mailstail](https://github.com/pcescato/mailstail) ]  
üí¨ Suggestions bienvenues, issues ouvertes !



Tu veux toi aussi reprendre le contr√¥le sur ta messagerie ? Alors bienvenue dans **mailstail**.
