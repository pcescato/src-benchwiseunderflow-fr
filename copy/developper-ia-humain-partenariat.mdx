---
title: "Développer avec l'IA sans perdre le contrôle : Claude, Mistral et moi"
pubDate: "2025-10-14T12:39:07+00:00"
updated: "2025-10-14T12:39:33+00:00"
slug: "developper-ia-humain-partenariat"
draft: false
categories:
  - "Tutoriels"
tags:
  - "IA"
  - "open source"
  - "performances"
  - "WordPress"
description: "Comment collaborer efficacement avec l'IA en développement ? J'ai utilisé Claude et Mistral en validation croisée pour transformer un plugin WordPress utilisé sur plus de 6000 sites. Résultat : 1h au lieu de 10 à 15h, 4 bugs critiques détectés, 40 erreurs corrigées en une passe. La méthode human-in-the-loop expliquée pas à pas."
image: /image/claude-mistral.avif

---

import { Code } from 'astro-expressive-code/components'


## Et si l'IA n'était ni un remplaçant, ni un simple assistant ?



Cet article n'est pas vraiment sur WordPress. Ni même sur un plugin de sécurité. **C'est un retour d'expérience sur une question qui obsède tous les développeurs :** comment collaborer efficacement avec l'IA sans devenir un simple subalterne qui copie-colle le code généré ?



**Mon laboratoire :** La refonte d'un plugin WordPress utilisé sur plus de 6000 sites.



**Mes partenaires IA :** [Claude (Anthropic)](https://claude.ai/chat/) et [Mistral AI](https://chat.mistral.ai/chat).



**Mon rôle :** chef d'orchestre, valideur, décideur final.



**Le résultat :**



* 1 heure de développement au lieu de 10 à 15 heures
* code conforme aux standards WordPress à 100%
* zéro régression sur les sites existants
* détection de bugs que j’aurais pu manquer seul



**Le secret ?** Pas l'IA. Pas l'humain. **La méthode de collaboration.**



Ce que vous allez découvrir :



* comment utiliser deux IA en validation croisée
* pourquoi Mistral a proposé du code buggé (et comment Claude l'a détecté)
* le workflow **human-in-the-loop** qui change tout
* les 40 erreurs que l'IA a corrigées en une passe
* ce que seul l'humain peut (et doit) faire



**Spoiler :** Le plugin WordPress n'est qu'un prétexte. La vraie histoire, c'est comment orchestrer plusieurs IA pour multiplier sa productivité par 20 sans sacrifier la qualité.



Prêt ? Plongeons dans cette collaboration humain-machine. Mais avant, je voudrais rappeler que…



## Ce n'est pas ma première expérience avec l'IA



Avant ce projet, j'avais déjà exploré la collaboration IA-développeur :



**Première expérience : [Générer une application complète avec Gemini CLI](/blog/generer-appli-complete-gemini-cli/)**



* découverte de l'approche CLI/terminal
* test de Gemini pour la génération automatisée
* premières intuitions sur le workflow



**Deuxième expérience : [Coder un plugin WordPress avec l'IA](/blog/coder-plugin-avec-ai/)**



* développement plus ciblé sur WordPress
* apprentissage des limites spécifiques
* compréhension de la validation nécessaire



**Cette troisième expérience apporte quelque chose de nouveau : la validation croisée.**



C'est la première fois que j'utilise **deux IA différentes** pour se valider mutuellement. Et c'est ce qui a tout changé.



## Le prétexte : un plugin WordPress en production



**[Stop XML-RPC Attacks](https://wordpress.org/plugins/stop-xml-rpc-attacks/)** : Un plugin WordPress minimaliste, actif sur plus de 6000 sites, conçu pour bloquer les attaques via XML-RPC tout en préservant la compatibilité avec Jetpack et WooCommerce, développé il y a 6 ans déjà [pour contrer les attaques de type DDoS sur mon blog](/blog/securite-attaques-xml-rpc/).



Pendant des années, la version 1.0.1 a parfaitement rempli son rôle avec une approche minimaliste : moins de 20 lignes de code, zéro configuration, efficace dès l'activation.

<Code code={`add\_filter('xmlrpc\_methods', function (\$methods) {
unset(\$methods['system.multicall']);
unset(\$methods['system.listMethods']);
unset(\$methods['system.getCapabilities']);
unset(\$methods['pingback.extensions.getPingbacks']);
unset(\$methods['pingback.ping']);
return \$methods;
});
add\_action('wp', function () {
header\_remove('X-Pingback');
}, 9999);
`} lang="php" />

**12 lignes de code. Zéro configuration. + de 6000 installations actives.**



Mais. Parce qu'il y a toujours un mais. Le plugin était efficace mais rigide. Pas d'options, pas de souplesse, pas de logs. Une solution "one-size-fits-all" qui ne convenait probablement pas à tous.



Le défi était de faire évoluer cette solution éprouvée sans casser ce qui fonctionne, tout en apportant la flexibilité nécessaire. En utilisant l'IA pour accélérer ce développement. Mais ce n'était pas au programme…



## Acte 1 : Mistral analyse (sans qu'on lui demande)



Un jour, pour montrer qu'on peut résoudre simplement un problème, j'ai présenté mon plugin à Mistral Le Chat :



### Mon message (sans rien demander) :



<samp>
J'ai développé un plugin WordPress pour moi - fonctionalité : bloquer les attaques via XML RPC tout en permettant l'utilisation de Jetpack par exemple - actif sur + de 6000 sites (stats WP) - actif dès l'activation, script de 12 lignes, zéro réglages  
  
[Code de la v1.0.1]
</samp>



**Je n'avais rien demandé. Juste présenté mon code.**



### La réponse de Mistral : une analyse complète non sollicitée



Mistral m'a répondu avec une analyse technique approfondie que je n'avais pas demandée :



<samp>
Voici une analyse technique et stratégique de votre plugin, ainsi que des améliorations possibles pour le rendre encore plus robuste, tout en gardant sa simplicité.
</samp>



**Points forts identifiés par Mistral :**



* la simplicité et efficacité du code
* le ciblage précis des méthodes dangereuses
* la compatibilité Jetpack/WooCommerce préservée
* la performance optimale (pas de requêtes DB)



**Limites détectées par Mistral :**



* une approche « liste noire » vs « liste blanche »
* une en-tête X-Pingback peut être réajouté par certains thèmes
* aucun log des tentatives d’attaque
* une compatibilité avec les plugins de cache incertaine



**Et surtout : Mistral m'a proposé une version "optimisée" complète**, avec :



* une architecture orientée objet avec singleton
* une interface d'administration avec dashboard
* trois modes de sécurité configurables
* un système de logging optionnel
* des options pour les utilisateurs avancés



### Ma première réaction



"Intéressant... mais est-ce vraiment mieux ?"



Avec **6000 sites en production**, je ne pouvais pas simplement copier-coller du code proposé par une IA, aussi convaincant soit-il.



**C'est là que commence la vraie histoire : la validation croisée.** Une partie de ping-pong à trois - Mistral et Claude face à moi qui renvoyait la balle à l'un ou à l'autre en fonction du contexte.



## Acte 2 : Claude détecte ce que Mistral a manqué



Face à cette proposition intéressante mais non sollicitée, j'ai eu un réflexe de développeur prudent : **demander un second avis**. J'ai pris le code proposé par Mistral et l'ai soumis à **Claude (Anthropic)** :



**Ma question à Claude :**



<samp>
Peux-tu me comparer ces 2 approches pour un plugin WP ?  
  
[Code original v1.0.1] vs [Code proposé par Mistral]
</samp>



Au-dela de l'interface d'administration, je voulais comprendre les différences réelles entre les deux versions, identifier les problèmes éventuels et ne pas céder aux sirènes de fausses bonnes idées qui pourraient, de plus, venir avec leur lot de bugs éventuels.



Et des bugs, il y en avait…



### Ce que Claude a immédiatement détecté



#### Bug critique #1 : conflits de filtres

<Code code={`// Ligne 13 : Option pour désactiver XML-RPC
add\_filter('xmlrpc\_enabled', '\_\_return\_false');
// Ligne 57 : Filtre qui s'exécute TOUJOURS (CONFLIT!)
add\_filter('xmlrpc\_enabled', function (\$enabled) {
if (!is\_user\_logged\_in()) return false;
return \$enabled;
});
`} lang="php" />

**Problème détecté par Claude :** les deux filtres se contredisent. Le second rend le premier totalement inutile. L'utilisateur qui choisit "Full Disable" se retrouverait avec un comportement différent de celui attendu.



**Mistral n'avait pas repéré ce conflit logique.**



#### Bug critique #2 : logging cassé

<Code code={`\$blocked = array\_diff(array\_keys(\$methods), array\_keys(\$methods));
if (!empty(\$blocked)) {
error\_log('Blocked methods: ' . implode(', ', \$blocked));
}
`} lang="php" />

**Problème détecté par Claude :** `array_diff()` d'un tableau avec lui-même retourne toujours un tableau vide ! Le logging ne fonctionnera jamais.



**Mistral avait proposé cette fonctionnalité... qui ne fonctionnait pas.**



#### Bug critique #3 : dégradation prévisible des performances

<Code code={`add\_filter('rewrite\_rules\_array', function (\$rules) {
foreach (\$rules as \$rule => \$rewrite) {
if (strpos(\$rewrite, 'xmlrpc.php') !== false) {
unset(\$rules[\$rule]);
}
}
return \$rules;
});
`} lang="php" />

**Problème détecté par Claude :** ce filtre est appelé à chaque requête et parcourt TOUTES les règles de réécriture WordPress. C'est coûteux, inutile, et peut dégrader les performances sur les 6000 sites.



**Mistral voulait améliorer la sécurité, mais sans se soucier des performances.**



#### Bug critique #4 : hook dans un hook

<Code code={`add\_filter('xmlrpc\_methods', function (\$methods) {
if (defined('SXRA\_LOG\_BLOCKED') && SXRA\_LOG\_BLOCKED) {
add\_filter('xmlrpc\_call', function (\$method) use (\$blocked) {
// Logging ici
});
}
return \$methods;
});
`} lang="php" />

**Problème détecté par Claude :** ajouter un filtre à l'intérieur d'un autre filtre crée des hooks en cascade et des comportements imprévisibles. WordPress n'est pas conçu pour ça.



### Le constat : Mistral avait raison sur le fond, tort sur la forme



**Ce que Mistral a bien fait :**



* identifier le besoin de flexibilité
* proposer une architecture moderne
* suggérer des fonctionnalités pertinentes
* apporter une vision stratégique correcte



**Ce que Mistral a manqué :**



* des bugs d'implémentation critiques
* des conflits logiques dans le code
* les standards WordPress n'étaient pas respectés
* l'impact sur les performances n'avait pas été anticipé



**Ce que Claude a apporté :**



* une détection précise des bugs
* la compréhension globale des standards WordPress
* des solutions d’implémentation correctes
* des explications pédagogiques pour chaque problème



## Acte 3 : L'humain orchestre et décide



À partir de là, le développement est devenu un véritable ping-pong entre les deux IA et moi :



### Le workflow en action

<Code code={`flowchart TD
A["Itération 1<br/>Architecture POO corrigée"] --> B["Tests locaux<br/>Problèmes de performance détectés"]
B --> C["Itération 2<br/>Optimisation des hooks"]
C --> D[Tests<br/>Conflits de constantes détectés]
D --> E["Itération 3<br/>Gestion des constantes améliorée"]
E --> F["Tests<br/>Besoin d'interface utilisateur"]
F --> G["Itération 4<br/>Ajout de l'interface admin"]
G --> H["Tests<br/>Problèmes i18n détectés"]
H --> I["Itération 5<br/>Internationalisation ajoutée"]
`} lang="mermaid" />

### Les itérations successives



**Itération 1 :** Architecture POO corrigée



* suppression des bugs de filtres
* singleton implémenté correctement
* structure de classe propre



**Itération 2 :** Optimisation des hooks



* suppression du filtre `rewrite_rules_array`
* hooks placés au bon moment du cycle WordPress
* performance préservée



**Itération 3 :** Gestion des options



* interface de configuration ajoutée
* trois modes de sécurité implémentés
* options stockées en base de données



**Itération 4 :** Interface d'administration



* tableau de bord avec statistiques
* design responsive et accessible
* descriptions claires pour chaque option



**Itération 5 :** Internationalisation



* Toutes les chaînes traduisibles (support multi-langues)
* Conformité aux standards i18n WordPress



### Mon rôle dans cette orchestration



**Ce que je n'ai pas fait :**



* écrire l'architecture *from scratch*
* implémenter manuellement l'interface d'administration
* chercher dans la documentation WordPress pendant des heures
* tester différentes combinaisons de hooks et priorités jusquà trouver la bonne combinaison



**Ce que j'ai fait (et que seul l'humain peut faire) :**



* décider quelle proposition de Mistral accepter ou refuser
* arbitrer entre les suggestions de Claude et mes contraintes
* tester à chaque étape avec WP\_DEBUG
* comprendre l’impact sur 6000 sites en production
* maintenir la philosophie « zéro configuration par défaut »
* valider que la complexité ajoutée apporte vraiment de la valeur



**L'IA propose. L'humain dispose.**



## Le moment de vérité : 40 erreurs invisibles



Après plusieurs itérations et des tests locaux tous réussis, il est temps de passer la main à **Plugin Check (PCP)**, l'outil officiel de validation.



### Premier essai



<samp>
❌ 40+ ERREURS ET WARNINGS
</samp>



Le plugin fonctionne parfaitement en local :


<samp>
* WP\_DEBUG : 0 erreur
* tests fonctionnels : OK
* compatibilité Jetpack : OK
* performance : excellente
</samp>


**Mais Plugin Checker ne valide pas (au contraire).**



### Les erreurs que ni Mistral, ni Claude, ni moi n'avions vues



#### Erreur #1 : Text Domain incorrect

<Code code={`// ❌ Le code généré par les IA - fonctionnel
define('SXRA\_TEXT\_DOMAIN', 'stop-xmlrpc-attacks');
\_\_('Security Mode', SXRA\_TEXT\_DOMAIN);
// ✅ Ce que WordPress.org exige
\_\_('Security Mode', 'stop-xmlrpc-attacks');
`} lang="php" />

**Raison :** le *text domain* doit être une chaîne littérale, pas une constante. Sinon les outils d'analyse de traduction de WordPress.org ne peuvent pas le détecter.



**Ni Mistral ni Claude ne connaissaient cette règle stricte.**



#### Erreur #2 : les échappements manquants

<Code code={`// ❌ Dangereux
\_e('XML-RPC Security', 'stop-xmlrpc-attacks');
// ✅ Sécurisé
esc\_html\_e('XML-RPC Security', 'stop-xmlrpc-attacks');
`} lang="php" />

**Raison :** toutes les sorties doivent être échappées, même celles qui semblent "sûres". C'est une règle de sécurité stricte.



**Les IA avaient utilisé les fonctions "classiques" sans échappement.**



#### Erreur #3 : fonction dépréciée

<Code code={`// ❌ Dépréciée depuis WordPress 4.6
add\_action('plugins\_loaded', function() {
load\_plugin\_textdomain('stop-xmlrpc-attacks', ...);
});
// ✅ Correct (ne rien faire!)
// WordPress.org charge automatiquement les traductions
`} lang="php" />

**Raison :** depuis WordPress 4.6, les traductions sont chargées automatiquement pour les plugins hébergés sur wordpress.org. Appeler `load_plugin_textdomain()` est devenu inutile et non recommandé.



#### Erreur #4 : commentaires traducteurs manquants

<Code code={`// ❌ Refusé par Plugin Check
echo sprintf(\_\_('Always blocked (%d):', 'stop-xmlrpc-attacks'), \$count);
// ✅ Accepté
/\* translators: %d: number of blocked methods \*/
echo sprintf(\_\_('Always blocked (%d):', 'stop-xmlrpc-attacks'), \$count);
`} lang="php" />

**Raison :** les traducteurs ont besoin de contexte pour comprendre ce que signifie le placeholder `%d`. C'est obligatoire pour toute chaîne avec placeholders.



**Aucune IA n'avait intégré cette règle.**



#### Erreur #5 : sanitization manquante

<Code code={`// ❌ Dangereux
\$ip = \$\_SERVER['REMOTE\_ADDR'];
// ✅ Sécurisé
\$ip = isset(\$\_SERVER['REMOTE\_ADDR'])
? sanitize\_text\_field(wp\_unslash(\$\_SERVER['REMOTE\_ADDR']))
: 'unknown';
`} lang="php" />

**Raison :** même `$_SERVER['REMOTE_ADDR']` doit être sanitizé selon les standards WordPress. C'est contre-intuitif (une IP fournie par le serveur), mais c'est la règle.



### Retour à Claude avec le rapport complet



**Ma demande à Claude :**



```
Voici les 40 erreurs du Plugin Check. Peux-tu corriger tout ça ?
```



**Claude** me propose une version complètement corrigée, avec :



* une explication pour chaque erreur
* la correction appropriée
* le code complet mis à jour



### Deuxième essai : essai transformé



<samp>
✅ 0 ERREUR  
✅ 0 WARNING  
✅ 100% CONFORME
</samp>



**Impressionnant.** Claude a corrigé les 40 problèmes **en une seule passe**, en comprenant non seulement ce qui était cassé, mais aussi **pourquoi et comment** WordPress voulait que ce soit fait.



**Temps écoulé pour cette correction : moins de 5 minutes avec Claude. Sans IA : probablement 1 à 2 heures de corrections et de tests.**



## Les leçons de cette collaboration



### Comment ma méthode a évolué au fil des expérimentations



#### Expérience 1 : Automatisation avec Gemini CLI



* génération rapide d'applications
* workflow automatisé
* contrôle limité sur les détails



#### Expérience 2 : Plugin WordPress avec Gemini CLI, Claude et ChatGPT



* plus de contrôle sur le code
* adapté au contexte WordPress
* validation manuelle extensive nécessaire via les IA



#### Expérience 3 (celle-ci) : Validation croisée avec deux IA



* détection automatique des bugs
* qualité supérieure
* confiance renforcée
* **la méthode qui change tout**



### Leçon 1 : Les IA ont des forces complémentaires



#### Mistral : le visionnaire stratégique



**Ses points forts :**



* une vision macro excellente
* la détection des faiblesses conceptuelles
* propose des architectures ambitieuses
* identification des besoins utilisateurs



**Ses points faibles :**



* peut proposer du code avec des bugs
* ne connaît pas toujours les standards spécifiques
* détails d'implémentation parfois incorrects



**Mistral est parfait pour du brainstorming, pour l'architecture initiale, pour l'identification des besoins.**



#### Claude : le technicien rigoureux



**Ses points forts :**



* détection de bugs très précise
* connaissance approfondie des standards
* explications pédagogiques détaillées
* code production-ready
* corrections en une passe



**Ses points faibles :**



* parfois plus conservateur
* peut manquer de vision "out of the box"



**Claude est parfait pour le debugging, la conformité, l'optimisation, la production**



### Leçon 2 : La validation croisée est indispensable



**Ce qui aurait pu mal tourner si j'avais fait confiance aveuglément en l'IA :**



#### Scénario A : Copier-coller du code Mistral



**Conséquences potentielles :**



* bugs dus aux conflits de filtres en production
* logging complètement non-fonctionnel
* une expérience utilisateur dégradée
* **impact négatif sur des milliers de sites**



#### Scénario B : Ne consulter qu'une seule IA



**Conséquences potentielles :**



* risque de manquer des optimisations importantes
* ou au contraire, sur-optimiser sans raison valable
* biais de l'IA non détecté
* bugs subtils non repérés



#### Scénario C : Faire confiance à 100% aux IA



**Ce qui s'est réellement passé :**



* 40 erreurs que les IA n'avaient pas anticipées
* standards WordPress que les IA ne connaissaient pas tous
* code déprécié (`load_plugin_textdomain` deprecated par exemple )



### Leçon 3 : L'humain reste le chef d'orchestre



**Ce que les IA ont fait pour moi :**



✅ **Mistral :**



* m'a proposé une architecture complète
* a identifié les limitations de la v1.0.1
* a suggéré des fonctionnalités pertinentes
* m'a présenté une vision stratégique du besoin utilisateur



✅ **Claude :**



* a détecté les bugs dans le code Mistral
* a corrigé les non-conformités aux standards
* m'a expliqué le "pourquoi" de chaque modification
* a généré du code production-ready



**Ce que seul l'humain peut (et doit) faire :**



* **Décider** : Accepter ou refuser chaque proposition
* **Arbitrer** : Entre complexité et simplicité
* **Comprendre** : L'impact sur plus de 6000 utilisateurs
* **Tester** : En conditions réelles, pas juste en théorie
* **Maintenir** : La philosophie du projet (zéro config par défaut)
* **Assumer** : La responsabilité du code déployé



**L'IA accélère. L'humain dirige.**



### Leçon 4 : Les tests automatisés ne suffisent pas



Un rappel important : le code parfait (en théorie) peut être refusé s'il ne suit pas les règles édictées par la plateforme.



**Avant Plugin Check :**



* WP\_DEBUG : 0 erreur
* tests fonctionnels : Tous OK
* compatibilité : Jetpack fonctionne
* performance : Excellente



**Après Plugin Check :**



* plus de 40 erreurs de conformité
* standards non respectés
* règles de sécurité violées
* bonnes pratiques ignorées



**Pourquoi ?** WordPress a des standards très stricts que les tests locaux ne peuvent pas détecter. Même les IA les plus avancées ne connaissent pas toutes ces règles spécifiques.



**La leçon :** Toujours valider avec les outils officiels, même quand tout fonctionne parfaitement.



## Le workflow human-in-the-loop idéal



Voici la méthode qui a émergé de cette expérience :

<Code code={`flowchart TD
A[Mistral propose des idées] --> B[Claude valide et corrige]
B --> C["Je teste en local<br/>(WP\_DEBUG activé)"]
C --> D[Plugin Check valide la conformité]
D --> E[Tests sur sites réels]
E --> F[Mise en production]
`} lang="mermaid" />

### Étape 1 : Brainstorming avec une IA "visionnaire"



**Action :** présenter le problème à Mistral (ou similaire)



**But :** obtenir des idées, une vision macro, des propositions architecturales



**Attitude :** écouter, noter, mais ne pas implémenter directement



### Étape 2 : Validation croisée avec une IA "rigoureuse"



**Action :** soumettre les propositions à Claude (ou similaire)



**But :** détecter les bugs, valider l'implémentation, corriger les erreurs



**Attitude :** cles deux avis, identifier les divergences



### Étape 3 : Décision humaine éclairée



**Action :** choisir ce qui a du sens pour le projet



**But :** préserver la philosophie, anticiper l'impact utilisateur



**Attitude :** l'IA propose, l'humain dispose



### Étape 4 : Implémentation itérative



**Action :** développer par petites itérations testables



**But :** valider à chaque étape, corriger rapidement



**Attitude :** tests locaux systématiques (WP\_DEBUG activé)



### Étape 5 : Validation avec outils officiels



**Action :** Plugin Check, tests de conformité



**But :** détecter ce que les IA et les tests locaux ont manqué



**Attitude :** accepter que même l'IA puisse ignorer certaines règles



### Étape 6 : Correction finale avec IA



**Action :** soumettre les erreurs détectées à Claude



**But :** corriger en une passe si possible tous les problèmes de conformité



**Attitude :** l'IA excelle dans ce type de tâche répétitive



### Étape 7 : Tests en conditions réelles



**Action :** déployer sur des sites de test variés



**But :** valider la compatibilité réelle



**Attitude :** rien ne remplace le monde réel



## Les chiffres de cette collaboration




| Métrique | Valeur |
| --- | --- |
| **Version initiale** | v1.0.1 (12 lignes de code) |
| **Version finale** | v2.0.0 (375 lignes de code) |
| **Message initial à Mistral** | 1 (présentation, pas de demande) |
| **Analyse Mistral** | Complète et détaillée (non sollicitée) |
| **Échanges avec Claude** | ~20 allers-retours |
| **Bugs détectés par Claude** | 4 bugs critiques dans le code Mistral |
| **Versions intermédiaires** | 5 itérations |
| **Erreurs Plugin Check** | de 40 à 0 en 1 passe |
| **Tests locaux** | 8 sites WordPress différents |
| **Temps total de dev** | environ 1 heure |
| **Temps estimé sans IA** | entre 10 et 15 heures |
| **Gain de temps** | ~90% |
| **Installations actives** | 6000+ |




## Le résultat : une solution flexible sans sacrifier la robustesse



### Ce qui a changé entre v1.0.1 et v2.0.0



**Architecture :**



* 12 lignes → 375 lignes (mais organisées en classe POO)
* approche procédurale → architecture orientée objet
* code inline → structure maintenable et extensible



**Fonctionnalités :**



* 1 mode → 3 modes de sécurité configurables
* 0 option → interface d'administration complète
* pas de logs → logging optionnel avec IP tracking
* 5 méthodes bloquées → 5 à 8 selon configuration



**Expérience utilisateur :**



* zéro configuration → toujours zéro configuration par défaut
* aucune souplesse → 3 niveaux de protection + options avancées
* pas de visibilité → tableau de bord avec statistiques en temps réel



### Ce qui n'a pas changé



**La robustesse :**



* toujours actif dès l'activation
* zéro configuration obligatoire
* compatibilité Jetpack / WooCommerce préservée
* performance optimale maintenue



**La philosophie :**



* "Ça marche out-of-the-box" reste la priorité
* les options sont pour ceux qui veulent plus
* la simplicité n'est pas sacrifiée à la flexibilité



**L'expérience par défaut :**



* un utilisateur qui active le plugin ou qui le met à jour sans rien toucher a exactement le même comportement qu'avec la v1.0.1
* la complexité est optionnelle, pas imposée



### Les trois modes de sécurité



#### Mode 1 : Full disable (sécurité maximale)



* désactive complètement XML-RPC
* pour les sites qui n'utilisent ni Jetpack, ni apps mobiles
* protection absolue contre toute attaque XML-RPC



#### Mode 2 : Guest disable (équilibré)



* XML-RPC désactivé pour les visiteurs non connectés
* autorisé pour les administrateurs authentifiés
* bloque les méthodes dangereuses même pour les admins



#### Mode 3 : Selective blocking (meilleure compatibilité) Par défaut



* bloque uniquement les 5 méthodes les plus dangereuses
* compatibilité totale avec Jetpack et WooCommerce
* le comportement exact de la v1.0.1, mais configurable



### L'interface d'administration



Accessible via **Réglages → XML-RPC Security** :



**Tableau de bord visuel avec :**



* le nombre de méthodes bloquées en temps réel
* le mode de sécurité actif
* l'état du logging



**Options claires :**



* une description détaillée pour chaque mode
* des codes couleur intuitifs (vert = sécurité max, jaune = équilibré)
* un avertissement sur l'impact de chaque option



**Options avancées :**



* blocage de l'énumération utilisateur (casse les apps mobiles)
* logging des attaques (uniquement si WP\_DEBUG actif)



## Conclusion : l'IA multiplie les forces, l'humain dirige



Ce projet m'a montré que le futur du développement logiciel n'est ni :



* l'IA remplace complètement le développeur
* le développeur fait tout manuellement sans assistance



Mais plutôt :



✅ **Le développeur orchestre plusieurs IA spécialisées**



* chaque IA apporte ses forces complémentaires
* la validation croisée détecte les faiblesses de chacune
* l'humain prend les décisions finales éclairées



✅ **Validation systématique et rigoureuse**



* des tests locaux avec WP\_DEBUG
* la validation avec des outils officiels (Plugin Check)
* des tests en conditions réelles
* accepter que même l'IA puisse se tromper



✅ **Responsabilité humaine inéliminable**



* comprendre l'impact sur les utilisateurs
* choisir entre propositions contradictoires
* maintenir la philosophie du projet
* assumer le code en production



### Le gain réel : 90% de temps, 100% de qualité



**Sans IA :** de 10 à 15 heures



* recherche d'architecture
* implémentation manuelle de l'interface
* debugging des problèmes de conformité
* lecture de documentation WordPress
* développement, tests et debug



**Avec IA :** environ 1 heure



* architecture proposée instantanément par Mistral
* bugs détectés en temps réel par Claude
* corrections des standards automatiques
* explications pédagogiques incluses
* conformité validée en 2 passes



La qualité finale est identique, voire supérieure, car :



* la validation croisée est plus rigoureuse que celle d'un développeur seul
* l'IA a détecté des bugs que j'aurais peut-être manqués
* la conformité aux standards est garantie
* l'architecture est aussi propre, voire plus propre que ce que j'aurais fait sans IA



### Ce que j'ai appris sur moi-même



Cette expérience m'a aussi appris quelque chose sur mon propre processus de développement :



**Avant l'IA, j'aurais probablement :**



* gardé le code minimaliste par flemme d'architecture
* évité l'interface admin "parce que c'est long"
* ignoré certains besoins utilisateurs par manque de temps



**Avec l'IA, j'ai pu :**



* oser une architecture ambitieuse
* créer une vraie interface utilisateur
* répondre aux besoins de différents types d'utilisateurs
* maintenir un code de qualité professionnelle sans effort surhumain



**L'IA ne m'a pas remplacé. Elle m'a rendu meilleur.**



## Les erreurs à éviter absolument



Fort de cette expérience, voici les pièges que j'ai identifiés :



### Erreur 1 : faire confiance aveuglément à une seule IA



**Pourquoi c'est dangereux :**



* chaque IA a ses biais et ses angles morts
* le code peut "sembler" correct sans l'être
* les bugs subtils passent inaperçus



**La solution :** toujours valider avec une seconde IA ou un second regard



### Erreur 2 : copier-coller sans comprendre



**Pourquoi c'est dangereux :**



* vous ne pourrez pas maintenir le code
* les bugs seront impossibles ou difficiles à corriger
* vous ne saurez pas expliquer vos choix techniques



**La solution :** demander des explications, comprendre avant d'implémenter



### Erreur 3 : ignorer les tests locaux



**Pourquoi c'est dangereux :**



* les IA peuvent proposer du code qui ne fonctionne pas
* les effets de bord ne sont pas anticipés
* la compatibilité réelle n'est pas testée



**La solution :** Tester chaque itération avec `WP_DEBUG` activé



### Erreur 4 : négliger les outils de validation officiels



**Pourquoi c'est dangereux :**



* les IA ne connaissent pas toutes les règles spécifiques
* les standards évoluent plus vite que les modèles d'IA
* Plugin Check détecte ce que les tests locaux manquent



**La solution :** Toujours valider avec Plugin Check (PCP) avant de déployer



### Erreur 5 : perdre de vue la philosophie du projet



**Pourquoi c'est dangereux :**



* l'IA peut proposer des features inutiles
* la complexité s'accumule sans valeur ajoutée
* on oublie ce qui fait la force du projet initial



**La solution :** Rester le gardien de la vision, arbitrer chaque ajout



**Un exemple ?** Claude m'a proposé d'utiliser l'opérateur `??=` de PHP 8.0 pour simplifier le singleton :

<Code code={`// PHP 7.4
public static function init() {
if (self::\$instance === null) {
self::\$instance = new self();
}
return self::\$instance;
}
// PHP 8.0+
public static function init() {
return self::\$instance ??= new self();
}
`} lang="php" />

**La proposition de Claude était techniquement correcte :** Code plus concis, plus lisible, plus "moderne".



**J'ai refusé. Voici pourquoi :**



**Les statistiques WordPress.org au moment du développement :**



* PHP 7.4 : **24,6%** des installations WordPress
* PHP 8.0+ : ~70% des installations
* PHP &lt;7.4 : ~5% des installations



En exigeant PHP 8.0+, je privais **près d'un quart des utilisateurs WordPress** (24,6%) d'un outil qui sécurise leur site.



Certes, passer à PHP 8.0 voire 8.1 est indispensable pour des raisons de sécurité. Le CMS préféré du web est forcément la cible privilégiée d'attaques de tout genre… autant ne prendre aucun risque. Mais ce n'est pas à mon plugin de forcer cette migration - surtout pour un gain esthétique de quelques lignes de code.



**Mon choix :** Privilégier la sécurité immédiate de plus de 6000 sites (dont potentiellement 1500 en PHP 7.4) à un code plus élégant.



**Claude ne pouvait pas faire ce choix.** Il ne connaît pas :



* la distribution réelle des versions PHP
* l'urgence du besoin de sécurité XML-RPC
* le contexte socio-technique (hébergeurs mutualisés, sites legacy, budget limité)
* ma philosophie "accessibilité maximale"



Pour un plugin de sécurité, **exclure 1 site sur 4 n'est pas acceptable**.



C'est exactement ça, le rôle de l'humain : **faire des choix contextuels basés sur des données réelles** que l'IA ne peut pas connaître.



L'IA propose le code **le plus moderne**. L'humain choisit le code **le plus utile**.



## Et si je devais recommencer ?



Avec le recul, voici ce que je changerais (ou pas) :



### Ce que je referais à l'identique



✅ **Utiliser deux IA en validation croisée**



* Mistral pour la vision stratégique
* Claude pour la rigueur technique
* et toujours l'humain pour orchestrer



✅ **Tester à chaque itération**



* `WP_DEBUG` activé en permanence
* tests sur plusieurs configurations
* validation continue



✅ **Ne jamais copier-coller aveuglément**



* youjours demander des explications
* comprendre avant d'implémenter
* rester le décideur final



## Les questions que vous vous posez probablement



### "Est-ce que ça marche pour tous les types de projets ?"



**Ma réponse :** Oui, mais avec des nuances.



**Ce flux de travail fonctionne bien pour :**



* la refonte de code existant
* l'ajout de fonctionnalités à un projet mature
* le debugging de code complexela conformité aux standards



**Fonctionne moins bien pour :**



* l'innovation algorithmique pure (l'IA reproduit ce qui existe)
* les problèmes nécessitant une compréhension métier profonde
* l'architecture de systèmes distribués complexes



### "Quelle IA choisir ?"



**Ma recommandation :**



**Pour la vision stratégique :**



* Mistral AI (excellent pour l'analyse et les propositions)
* ChatGPT-5 (très créatif sur les architectures)



**Pour la rigueur technique :**



* Claude (Anthropic) - mon préféré pour le debugging
* ChatGPT-5 (très bon aussi, mais parfois moins précis)



**L'important :** En utiliser **au moins deux** en validation croisée.



### "Combien ça coûte ?"



**Pour ce projet :**



* Mistral AI : Gratuit (version Le Chat)
* Claude : Gratuit (version Claude.ai)
* **Total : 0€**



**Si vous utilisez les API payantes :**



* Mistral API : ~0,50€ pour un projet comme celui-ci
* Claude API : ~1-2€ pour un projet comme celui-ci
* **Total : ~2€ maximum**



**Comparé à 10/15 heures de développement :** ROI absolument démentiel.



### "Et la sécurité du code généré par l'IA ?"



**Mon expérience :**



**Les IA sont bonnes pour :**



* l'échappement de sortie (si on le leur demande)
* la sanitization des entrées (généralement)
* la validation des données (la plupart du temps correcte)



**Mais peuvent manquer :**



* les règles spécifiques au framework (d'où les 40 erreurs Plugin Check)
* les failles subtiles liées au contexte
* l'impact sur la performance



**La solution : toujours faire auditer par les outils officiels.**



### "L'IA va-t-elle remplacer les développeurs ?"



**Ma conviction après cette expérience : Non.**



**Ce qui va changer :**



* les développeurs vont devenir des "orchestrateurs d'IA"
* le code "boilerplate" sera généré instantanément
* le debugging sera énormément accéléré
* les standards et la conformité seront plus faciles à respecter



**Ce qui ne changera pas :**



* le besoin de comprendre le contexte métier
* la nécessité d'arbitrer entre solutions contradictoires
* la responsabilité du code en production
* la vision architecturale à long terme
* la compréhension des besoins utilisateurs réels



**L'IA rend les bons développeurs meilleurs. Elle ne transforme pas les non-développeurs en développeurs.**



## Ressources et liens



### Le plugin



* **Dans le dépôt WordPress :** [Stop XML-RPC Attacks](https://wordpress.org/plugins/stop-xml-rpc-attacks/)
* **Repository SVN :** [https://plugins.svn.wordpress.org/stop-xml-rpc-attacks/tags/](https://plugins.svn.wordpress.org/stop-xml-rpc-attacks/tags/) (versions 1.0.1 et 2.0.0)
* **Statistiques :** 6000+ installations actives



### Les IA utilisées



* **Mistral AI :** [Le Chat](https://chat.mistral.ai/)
* **Claude (Anthropic) :** [Claude.ai](https://claude.ai/)



### Outils de validation



* **Plugin Check (PCP) :** [Plugin officiel](https://fr.wordpress.org/plugins/plugin-check/)
* **WP\_DEBUG :** Documentation sur [developer.wordpress.org](https://developer.wordpress.org/advanced-administration/debug/debug-wordpress/)



### Pour aller plus loin



* **Standards WordPress :** [WordPress Coding Standards](https://developer.wordpress.org/coding-standards/)



## Conclusion finale : une collaboration qui redéfinit le développement



Ce projet a affiné ma perception de l'IA en développement. Ce n'est ni un assistant magique, ni un simple outil. **C'est un partenaire de collaboration avec ses forces et ses faiblesses.**



**Les chiffres :**



* 1 heure au lieu de 10 à 15 heures
* 0 régression sur plus de 6000 sites
* 4 bugs critiques détectés par validation croisée
* 40 erreurs de conformité corrigées en une passe
* 375 lignes de code production-ready



**Mais au-delà des chiffres :**



* une architecture que je n'aurais pas osé tenter seul
* une qualité de code supérieure à ce que j'aurais fait manuellement
* des standards respectés que j'aurais probablement ignorés
* la flexibilité sans perdre la simplicité d'utilisation



**Le secret ?** Pas l'IA. Pas l'humain. **La méthode de collaboration.**



**Human-in-the-loop** n'est pas un buzzword. **C'est une nécessité**. L'IA **propose, détecte, corrige**. L'humain **décide, arbitre, assume**. Ensemble, ils créent quelque chose qu'aucun des deux n'aurait pu faire seul.



**Mon analyse finale :**



* Si vous développez en 2025 sans utiliser l'IA, vous perdez un temps précieux.
* Si vous développez en 2025 en faisant confiance aveuglément à l'IA, **vous prenez des risques énormes**.



**La bonne approche :**



* utilisez plusieurs IA en validation croisée
* testez systématiquement à chaque étape
* validez avec les outils officiels
* comprenez avant d'implémenter
* restez le chef d'orchestre



**L'IA est un accélérateur. Pas un pilote automatique.**



## Votre expérience avec l'IA en développement ?



Avez-vous déjà utilisé plusieurs IA en validation croisée pour un projet ? Quelles ont été vos découvertes et vos pièges ? Êtes-vous d'accord avec l'approche *"human-in-the-loop"* ?



**Partagez votre expérience en commentaire !**
